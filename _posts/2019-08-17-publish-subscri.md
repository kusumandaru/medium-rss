---
layout: post
title: Publish subscribe on ruby on rails
author: ndaru
categories: ["publish-subscribe", "ruby-on-rails", "rabbitmq"]
image: https://cdn-images-1.medium.com/max/1024/1*23WsqANJv5IS4ar-LGU2sw.jpeg
---
<p>Using RabbitMQ bunny and sneakers</p><p>This tutorial contain example how to implement service oriented architecture on ruby on rails, using RabbitMQ, bunny as producer and sneakers as consumer. This introduction accommodating step by step from first installation.</p><p>I got idea from <a href="https://medium.com/@himang27s/background-job-in-rails-using-rabbitmq-and-sneaker-449c07284abf">this</a> medium post and adding some additional step.</p><h4>Initiation and environment setup</h4><p>First of all, we create skeleton of rails, using command: rails new {branch_name} -d mysql, this function create basic rails file and folder and using database mysql instead default sqlite.</p><p>After files are initiated, go to folder via cd {branch_name} and then type bundle to install rails dependencies. After success go to config/database.yml and set some environment variable like host, username and password.</p><pre>default: &amp;default  <br>adapter: mysql2<br>encoding: utf8  <br>pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 } %&gt;  <br>host: &lt;%= ENV.fetch(&quot;RAILS_HOST_DB&quot;) %&gt;  <br>username: &lt;%= ENV.fetch(&quot;RAILS_USERNAME_DB&quot;) %&gt;  <br>password: &lt;%= ENV.fetch(&quot;RAILS_PASSWORD_DB&quot;) %&gt;  <br>socket: /tmp/mysql.sock</pre><p>For development convenience i set some environment on .env and read using gem dotenv-rails, on Gemfile add gemfile &#39;dotenv-rails&#39; on group :development, :test section and type bundle again in terminal. After dependencies were updated, create .env file on root folder and fill like</p><pre>RAILS_HOST_DB=127.0.0.1<br>RAILS_USERNAME_DB=root<br>RAILS_PASSWORD_DB=secret_password</pre><p>also on config/application.rb add new line Dotenv::Railtie.load</p><p>Do initialize database using command rails db:create , and voila now on your mysql instance, two database created.</p><p>We continue to create model using command rails generate model User first_name:string last_name:string email:string , it will automatically generate model, test/model and migration file on db/migrate.</p><p>Try to runrails db:migrate to create table and column on schema database.</p><p>Since we try using rspec and shoulda matcher to test, we adding additional gem on test section</p><pre>gem ‘rspec-rails’</pre><pre>gem ‘shoulda-matchers’</pre><p>and again type bundle and additional rails generate rspec:install to create spec_helper and rails_helper</p><p>Finally we back to model User.rb and add simple validation like validates :first_name, :last_name, :email, presence: true to make validation of mandatory variable</p><h4>Set publisher</h4><p>Install rabbitMq client, one of gem is <a href="https://github.com/ruby-amqp/bunny">bunny</a> using command:gem install bunny and set initializer. You can use initializers to hold configuration settings that should be made after all of the frameworks and plugins are loaded.</p><p>create new file on config/initializers/publisher/bunny_publisher.rb than set logger and connection. for simpliest setup can be used like Bunny.new(&quot;amqp://guest:guest@localhost:5672&quot;) but we can also set more advance setting like :</p><pre>@connection ||= begin</pre><pre>  instance = Bunny.new(</pre><pre>    addresses: &#39;localhost:5672&#39;,</pre><pre>    username: &#39;guest&#39;,</pre><pre>    password: &#39;guest&#39;,</pre><pre>    vhost: &#39;/&#39;,</pre><pre>    logger: Rails.logger</pre><pre>  )</pre><pre>  instance.start</pre><pre>  instance</pre><pre>end</pre><p>It will create connection when not initiated before.</p><p>After initializer created you can create service on app/services/user_publisher.rb , with main method publish</p><pre>def publish(options = {})</pre><pre>  channel = ::Publisher::BunnyPublisher.connection.create_channel</pre><pre>  exchange = channel.exchange(</pre><pre>    &#39;sneakers&#39;,</pre><pre>    type: &#39;direct&#39;,</pre><pre>    durable: true</pre><pre>  )</pre><pre>  headers = { &#39;x-delay&#39; =&gt; options[:delay_time].to_i * 1_000 } if options[:delay_time].present?</pre><pre>  exchange.publish(payload.to_json, routing_key: QUEUE_NAME, headers: headers)</pre><pre>end</pre><p>make sure queue name in publisher same with customer, than publisher ready to use.</p><h4>Set consumer</h4><p>For background processing consumer we choose <a href="https://github.com/jondot/sneakers">sneakers</a>, install via gem install sneakers</p><p>create initializer on config/initializers/sneakers.rb and set configuration:</p><pre>Sneakers.configure  connection: Connection.sneakers,</pre><pre>  exchange: &#39;sneakers,</pre><pre>  exchange_type: :direct,</pre><pre>  runner_config_file: nil,</pre><pre>  metric: nil,</pre><pre>  workers: 1,</pre><pre>  log: STDOUT,</pre><pre>  pid_path: &#39;sneakers.pid&#39;,</pre><pre>  timeout_job_after: 5.minutes,</pre><pre>  env: ENV[&#39;RAILS_ENV&#39;], </pre><pre>  durable: true,</pre><pre>  ack: true,</pre><pre>  heartbeat: 2,</pre><pre>  handler: Sneakers::Handlers::Maxretry</pre><pre>Sneakers.logger = Rails.logger</pre><pre>Sneakers.logger.level = Logger::WARN</pre><p>we choose <strong>ack</strong> option to be true to make sure message must be acknowledge when process is finished on consumer</p><p>and then we create worker on app/workers/user_create.rb</p><pre>include Sneakers::Worker</pre><pre>QUEUE_NAME = ::UserPublisher::QUEUE_NAME</pre><pre>from_queue QUEUE_NAME, arguments: { &#39;x-dead-letter-exchange&#39;: &quot;#{QUEUE_NAME}-retry&quot; }</pre><pre>def work(msg)</pre><pre>  data = ActiveSupport::JSON.decode(msg)</pre><pre>  data[&#39;users&#39;].each do |user|</pre><pre>    update_user(user.to_h)</pre><pre>  end</pre><pre>  ack!</pre><pre>rescue StandardError =&gt; e</pre><pre>  create_log(false, data, message: e.message)</pre><pre>  reject!</pre><pre>end</pre><p>so on above code we get message from rabbitMq and we decode and iterate and update 1 by one, when no raise error it will call ack! to inform in RabbitMq if message already done processed</p><p>now we can call consumer rake, via rake sneakers:run, make sure in ENV WORKERS=UserCreate it scan worker folders with class_name UserCreate</p><p><strong>Test publishing and consuming</strong></p><p>To publish you can call UserPublisher and it will consumed automatically.</p><pre>irb(main):002:0&gt; user_params = [{id: 1, first_name: &#39;first&#39;}]<br>=&gt; [{:id=&gt;1, :first_name=&gt;&quot;first&quot;}]<br>irb(main):003:0&gt; UserPublisher.new(user_params).publish</pre><p>on cosumer it will wait for any message</p><pre>rake sneakers:run           <br><br>2019-08-17T05:36:41Z p-83921 t-owt7p5uik DEBUG: [worker-user.create:1:d5ckph][#&lt;Thread:0x00007fd5b0885d78 run&gt;][user.create][#&lt;Sneakers::Configuration:0x00007fd5b6efd240&gt;] New worker: subscribing.</pre><pre>2019-08-17T05:36:41Z p-83921 t-owt7p5uik DEBUG: [worker-user.create:1:d5ckph][#&lt;Thread:0x00007fd5b0885d78 run&gt;][user.create][#&lt;Sneakers::Configuration:0x00007fd5b6efd240&gt;] New worker: I&#39;m alive.</pre><pre>2019-08-17T05:41:03Z p-83921 t-owt7x84vw DEBUG: [worker-user.create:1:d5ckph][#&lt;Thread:0x00007fd5b225af78@/Users/ndaru/.rbenv/versions/2.5.0/lib/ruby/gems/2.5.0/gems/bunny-2.14.2/lib/bunny/consumer_work_pool.rb:101 run&gt;][user.create][#&lt;Sneakers::Configuration:0x00007fd5b6efd240&gt;] Working off: &quot;{\&quot;users\&quot;:[{\&quot;id\&quot;:1,\&quot;first_name\&quot;:\&quot;first\&quot;}]}&quot;</pre><p>You can trace repository in <a href="https://github.com/kusumandaru/rails_queue"><strong>here</strong></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*23WsqANJv5IS4ar-LGU2sw.jpeg" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6aa6893ef819" width="1" height="1">