---
layout: post
title: Encrypt decrypt Rails attribute using MessageEncryptor
author: ndaru
categories: ["encryption", "rails", "salt"]
image: https://cdn-images-1.medium.com/max/640/1*Ze_S6uRvYBZLQxS4xBysHg.jpeg
---
<p>How we secure sensitive data using Rails MessageEncryptor, from plain attributes to secured one.</p><p>This article combined from <a href="https://security.stackexchange.com/questions/17421/how-to-store-salt">store salt beside hashed attributes</a> and article from Pawel urbanek about <a href="https://pawelurbanek.com/rails-secure-encrypt-decrypt">message encryptor</a>.</p><p>For this example each salt is located in same record encrypted attribute. It use a salt ‘works’ by making sure the hash result unique to each used instance. This is done by picking a different random salt value for each computed hash.</p><p>MessageEncryptor is rails function which have ability to encrypt decrypt value use base64 encoded. It using key which generate from combination password , salt and length . For now it use ActiveSupport::MessageEncryptor.key_len which have 32 since ruby from version 2.4.0 forward use open ssl which have 32 bytes length.</p><p><strong>Service to encrypt and decrypt</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d6f122d5d193a27bbed5ad081b25b089/href">https://medium.com/media/d6f122d5d193a27bbed5ad081b25b089/href</a></iframe><p>It define initialise, so each new method will create encryptor/decryptor based on salt record. Then it can encrypt or decrypt attribute.</p><p>It read key ENCRYPT_KEY_BASE from environment variable, make sure key not uploaded to repository and try to make unique for production and staging environment. Also create using hard random key like SecureRandom.base64 or SecureRandom.random_bytes</p><h4>Define concern</h4><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/43d81d7c0e8f31943d5127e8f9767ea8/href">https://medium.com/media/43d81d7c0e8f31943d5127e8f9767ea8/href</a></iframe><p>We use meta programming ruby to override class method attr_encrypted for each attribute which assigned and and assign value to encrypted_attribute</p><p>Example: attr_encrypted :mother_name, on_model user, it will overriding attribute mother_name with decrypted value and reassign value for attribute encrypted_mother_name with encrypted value. You can assign multiple attribute also on these class method</p><p>It send salt from record and encrypted_attribute to encryption service, either to encrypt or decrypt data.</p><p>When salt not exist on those record, it also built automatically use ActiveActiveSupport::MessageEncryptor.key_len a.k.a SecureRandom.random_bytes(32)</p><h4>Migrate plain attributes to encrypted one</h4><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cdb827fc2e5fa504290aeb18c37928c5/href">https://medium.com/media/cdb827fc2e5fa504290aeb18c37928c5/href</a></iframe><p>After service and model already done we try to migrate unencrypted data, we define new column with prefix encrypted_ and we add salt with type binary, in postgres it will save with format bytea. Cause salt cannot save in format string.</p><p>We also define user.mother_name = user.mother_name_was since method mother_name already override on above concern, and mother_name_was is directly call active record.</p><p>For better security try to store salt in different source. Like different database, or access by another endpoint, so when database was breach, key is on another world.</p><p>Alternatively you can use third party cryptography service like aws/google cloud KMS, vault, or thales.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*Ze_S6uRvYBZLQxS4xBysHg.jpeg" /><figcaption><a href="https://unsplash.com/photos/0Yiy0XajJHQ">https://unsplash.com/photos/0Yiy0XajJHQ</a></figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=85e10dfe90d7" width="1" height="1" alt="">